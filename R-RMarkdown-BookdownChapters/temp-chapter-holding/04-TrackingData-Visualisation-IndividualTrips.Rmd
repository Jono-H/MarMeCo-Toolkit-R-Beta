# Tracking data: Visualise individual trips

<!--- This is an HTML comment in RMarkdown. You can use these comments to make notes that won't get read when running the code -->

<!--- If you don't understand what a RMarkdown document is. Stop here. Go learn. -->

<!--- Equally. You must understand the difference between Markdown vs. RMarkdown -->

<!--- Remember, outside of the R code chunks we are now coding in HTML syntax, not R syntax -->

**This chapter is a continuation from the previous chapter viewing all tracking data. It requires the outputted data file from the previous chapter**

<!--- In the code chunk below, we specify include = F, so that we will run the chunk but not include the chunk in the final document. We set a global argument in the code chunk of echo = T, so that in later code chunks, the code will be displayed in the RMarkdown document -->

```{r track-vis-ind-setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
## we also specify in the options here to set the overall working directory
## back to the root directory of the R Project we are working in. We do this
## because by default , the working directory for R code chunks is the directory 
## that contains the Rmd document. We don't want this option given our file
## set up prefers the option of having the working directory specified as that
## where the R Project is. By specifying double dots (or more), this is like saying
## go back one directory or more, as required.
knitr::opts_knit$set(root.dir = "..")
```

<br>

## Description of data

<!--- remember, single * is italics, ** is bold -->

The example data for this chapter relates to the previous. It has just add some additional columns added which help to specify start and end of the overall track.

## Goal of chapter:

The previous chapter ended by noting: In some cases, an entire track may be worth disregarding or trying to salvage. However, it often might be the case that only certain trips from the entire period an animal was tracked may be worth removing or require salvaging.

This chapter will help split tracks into trips and support options for assessing quality of individual trips prior to input into the track2KBA protocol.


## Load packages

**Load required R packages:**

If the package(s) fails to load, you will need to install the relevant package(s).

```{r track-vis-ind-load-packages, include = TRUE}

## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Load libraries --------------------------------------------------------------
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

"Had to install R version: R version 4.2.2 (2022-10-31 ucrt) for aniMotum"
## Options to install aniMotum package for animal track interpolation
## aniMotum: https://besjournals.onlinelibrary.wiley.com/doi/10.1111/2041-210X.14060
#install.packages('aniMotum', repos = c('https://ianjonsen.r-universe.dev', 'https://cloud.r-project.org'))
# may need to install aniMotum after downloading using: devtools::install_local(package.zip)
#install.packages('TMB', type = 'source')
library("aniMotum")
## sf package for spatial data analyses (i.e. vector files such as points, lines, polygons)
library(sf)
## Tidyverse for data manipulation
library(tidyverse)
## ggplot2 for plotting opionts
library(ggplot2)
## rnaturalearth package for basemaps in R
library(rnaturalearth)
## leaflet package for interactive maps in R
#install.packages("leaflet")
library(leaflet)
##
library(purrr)
library(furrr)
#install.packages("track2KBA")
library(track2KBA)
## for date time
library(lubridate)
## for stats
library(stats)
## speed filter
library(trip)
## linear interpolation
library(adehabitatLT)

```

<br>

## Input parameters for chapter tutorial

Here we define input parameters needed for sections of the code later in this tutorial.

Depending on how your data is set up, you should not need to define any further input parameters.

```{r track-vis-ind-input-parameters, include = TRUE}

## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Specify projections / store needed CRS definitions as variables ----
## SEE: https://epsg.io/
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## world - unprojected coordinates
wgs84 <- st_crs("EPSG:4326")

## Croatia -  projected coordinates
htrs96 <- st_crs("EPSG:3765")

## Source a world map from the rnaturalearth R package
## see details of function to change the type of map you get
worldmap <- rnaturalearth::ne_download(scale = "large",
                                       type = "countries",
                                       category = "cultural",
                                       destdir = tempdir(),
                                       load = TRUE,
                                       returnclass = "sf")

```


<br>

## Load input example data and prepare for track2KBA R package protocol

Loading the input example data

```{r track-vis-ind-load-data, include = TRUE}

## Load the example data for Yelkouan Shearwaters
load("data-testing/tracking-data/Tracking_YESH_raw_step2.Rdata")

## view the first two rows of data
## First view the data in tibble format
head(df_sbtd_sf,2)
## Then view the data in data frame format
head(data.frame(df_sbtd_sf),2)
## convert back to dataframe
df_sbtd <- df_sbtd_sf %>% st_drop_geometry() %>% data.frame()

```

## track2KBA::formatFields()

This function will help format your data to align with that required of track2KBA.

In other words: for the track2KBA functions to work, your data needs to have certain columns named in the appropriate way. This function will help with that.

```{r track-vis-ind-formatFields, include = TRUE}

## Format the key data fields to the standard used in track2KBA
dataGroup <- formatFields(
  ## your input data.frame or tibble
  dataGroup = df_sbtd, 
  ## ID of the animal you tracked
  fieldID   = "bird_id", 
  ## date in GMT
  fieldDate = "date_gmt", 
  ## time in GMT
  fieldTime = "time_gmt",
  ## longitude of device
  fieldLon  = "lon_device", 
  ## latitude of device
  fieldLat  = "lat_device"
)

## Check output. Output is a data.frame
head(dataGroup)
str(dataGroup)


```

## Quick visual inspection of your data

Check your data is still correct spatially


```{r track-vis-ind-review-dataGroup, include = TRUE}

## quick plot of all data for a quick overview
dataGroup.plot <- st_as_sf(dataGroup, coords = c("Longitude", "Latitude"), crs=4326) # 4326 = geographic WGS84
plot(st_geometry(dataGroup.plot), 
     cex = 0.5, 
     pch = 1)

## number of datapoints
nrow(dataGroup)

## interactive plot
leaflet() %>% ## start leaflet plot
  addProviderTiles(providers$Esri.WorldImagery, group = "World Imagery") %>% 
  ## plot the points. Note: leaflet automatically finds lon / lat colonies
  ## Colour accordingly.
  addCircleMarkers(data = dataGroup,
                   radius = 3,
                   fillColor = "cyan",
                   fillOpacity = 0.5, stroke = F) 


```

## Define colony / origin of trips ----

This supports application of the tripSplit function

You must consider how you define your colony of origin for each of the tracked animals

```{r track-vis-ind-col-locs, include = TRUE}

"OPTION 1: Same unique colony for all birds"
## example relates to a seabird during the breeding season, when the species
## is known to be a central place forager. Therefore, define the colony position
## based on the first longitude and latitude coordinates which SHOULD originate
## from the breeding colony if all birds tracke appropriately from the same colony
colony <- dataGroup %>% 
  summarise(
    Longitude = first(Longitude), 
    Latitude  = first(Latitude)
  )

##
head(colony)

## Or, manually specify a unique Lon / Lat
# colony <- dataGroup %>% 
#   summarise(
#     Longitude = 16.875879, 
#     Latitude  = 42.774843
#   )


"OPTION 2: Specify unique colony or unique nest per bird"
## IF colony / nest locations vary more widely, then create unique dataframe
## for each bird / animal tracked. Specify a unique nesting location for each
## animal based on the first coordinate of the track.

colony_nest <- dataGroup %>% 
  group_by(ID) %>% 
  summarise(
    ID = first(ID),
    Longitude = first(Longitude), 
    Latitude  = first(Latitude)
  ) %>% 
  data.frame()

##
head(colony_nest)

```

### Are your colony locations where you expect them to be?

For tripSplit to work best, you want the colony locations to reflect where the colony actually is. If you did not clean or prepare your data appropriately, it may be the case that the colony locations are specified incorrectly.

If your colony locations are incorrectly placed, consider appropriate action.

```{r track-vis-ind-col-locs-checking, include = TRUE}

## interactive plot - review where the individual colony location records
## were deemed to be.
map <- leaflet() %>% ## start leaflet plot
  addProviderTiles(providers$Esri.WorldImagery, group = "World Imagery") %>% 
  ## plot the points. Note: leaflet automatically finds lon / lat colonies
  ## Colour accordingly.
  addCircleMarkers(data = data.frame(dataGroup),
                   radius = 3,
                   fillColor = "cyan",
                   fillOpacity = 0.5, stroke = F) %>% 
  ## plot the colony locations from birds
  addCircleMarkers(data = data.frame(colony_nest),
                   radius = 5,
                   fillColor = "red",
                   fillOpacity = 0.5, stroke = F) 

map

```

> CONSIDER: Based on your review of the data and knowledge of the study sytem, are the colony locations where you expect them to be? If not, consider appropriate action. For example, create a new dataframe with the relevant colony locations for each tracked individual.

[What other options exist to correct colony location data where required?]

## Apply tripSplit()

**What does tripSplit do:** [update text from track2KBA manuscript]

**When not to apply tripSplit():** "If your data does not relate to a central place forager (CPF), OR
a time when an animal may be exhibiting central place foraging behaviours,
then skip this section and those relating to CPF data."

**How tripSplit() helps:**"This step is often very useful to help automate the removal of location points
on land, or near the vicinty of a colony. We don't want these extra points to bias
our interpretation of the data."

**General considerations when applying tripSplit():** "The user must define ecologically sensible parameters to help automate the tripSplitting process."

```{r track-vis-ind-tripSplit, include = TRUE}

## Input is a 'data.frame' of tracking data and the central-place location(s). 
## Output is a 'SpatialPointsDataFrame'.
trips <- tripSplit(
  dataGroup  = dataGroup,
  colony     = colony_nest, # define source location.
  innerBuff  = 3,      # km - defines distance an animal must travel to count as trip started
  returnBuff = 10,     # km - defines distance an animal must be from the colony to have returned and thus completed a trip
  duration   = 1,      # hours - defines time an animal must have traveled away from the colony to count as a trip. helps remove glitches in data or very short trips that were likely not foraging trips.
  nests = T,           # specify nests = T if using unique colony locations per animal,
  gapLimit = NULL, # The period of time between points (in days) to be considered too large to be a contiguous tracking event
  rmNonTrip  = F    # If true, points not associated with a trip will be removed / if false, points not associated with a trip will be kept
)

"NOTE: the messages that may relate to 'track .... does not return to the colony',
is actually referring to the individual trips from each animal tracked. The code
for track2KBA package needs to be revised to display an '_' between the track ID 
and the individual trip ID. So instead of reading something like 693041, it should
read 69304_1, to better refer to trip 1 of track 69304." 

## Review data after tripSplit()
head(trips,2)
str(trips)
table(trips$Returns)

```

### Review of tripSplit() output

In the example above, we specified `rmNonTrip = F` so as not remove any points not deems as associated with a trip. I.e. the points typically lying within the `innerBuff` distance and for those where the animal travelled for less than `duration` specified,

Let's review the general points we are not considering as part of trips.

```{r track-vis-ind-tripSplit-review, include = TRUE}

## Simple plot of data after tripSplit
"NOTE: Will take time depending on size of dataset! Considering general plotting
etiquetter when working with data in R."
plot(st_geometry(st_as_sf(trips)), 
     cex = 0.5, 
     pch = 1)

## Split the locations into points to keep and those that will be removed (i.e.
## the points not associated with a trip) for visual plot of the tracks using leaflet package in R.
points_to_keep <- data.frame(trips) %>% 
  dplyr::filter(Returns %in% c("Yes", "No"))
##
points_to_remove <- data.frame(trips) %>% 
  dplyr::filter(!Returns %in% c("Yes", "No"))

map <- leaflet() %>% ## start leaflet plot
  addProviderTiles(providers$Esri.WorldImagery, group = "World Imagery") %>% 
  ## plot the points. Note: leaflet automatically finds lon / lat colonies
  ## Colour accordingly.
  addCircleMarkers(data = points_to_keep,
                   radius = 3,
                   fillColor = "cyan",
                   fillOpacity = 0.5, stroke = F) %>% 
  ##
  addCircleMarkers(data = points_to_remove,
                   radius = 3,
                   fillColor = "red",
                   fillOpacity = 0.5, stroke = F)
  
map

```

### Understanding what is happening in tripSplit() further

Essentially, we are using a function that helps us bulk clean tracking data. The goal is to assign individual trips to multiple animals that have been tracked, and doing this in an automated way.

> Go back and change `innerBuff` and `duration` parameters in particular, and recreate the plot above showing the points not associated with a trip. See how changing the arguments impacts the likely data that will be removed for the analysis. You only want to remove (i.e. "clean up") the points that are most likely not associated with a trip.


### Review the individual trips for each tracked animal after applying tripSplit()

A simple way to do this is with the `mapTrips` function.

The plots show an overview of individual trips per bird. Only data for the first 25 birds is shown.

```{r track-vis-ind-mapTrips, include = TRUE}

## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## track2KBA::mapTrips() ----
## view data after splitting into trips ----
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## plot quick overview of trips recorded for individual birds (i.e. the plots show
## an overview of individual trips per bird). Only data for the first 25 birds is
## shown
mapTrips(trips = trips, colony = colony_nest)

## If you want to map the trips from the next 25 animals tracked, use the IDs argument
mapTrips(trips = trips, IDs = 26:50, colony = colony_nest)

```

### Plot the individual trips for each tracked animal after applying tripSplit()

If, after reviewing the simplified plots of individual trips for each tracked animal using the `mapTrip()` function you are not satisfied, then you should explore the relative data further.

[One way of exploring the trips outputted for individually tracked animals would be to rapidly review summary plots for each trip, showing start, journey, and end points, where the point locations are also joined together with a line. Should consider inlcuding this plotting option. Perhaps also with option of specifying a vector of relative individuals.]

## Keep points associated with complete trips only

> Keeping points associated with complete tracks only is the approach considred in the `track2KBA` online tutorial. But you may want to explore which tracks you are keeping or not.

> Here, the user should consider if too many individual trips have been removed.
i.e. if you tracked 30 birds and you estimated to have approximately 3 trips 
recoreded per bird, then you would have a total of 90 trips. But it's likely that
on some trips, that not the entire trip was recorded (for multiple reasons).
Therefore, you might expect to rather have about 83 trips recorded across all
birds because for 7 trips data might not have indicated birds returned to the colony.
If you had a very high proportion of trips that did not return to the colony, then
it's likely that you have defined the parameters incorrectly for tripSplit and you
should reconsider better ecologically based estimates for these parameters. There
is of course the chance that there are other issues with your data which would warrant
more detailed exploration.

```{r track-vis-ind-keep-complete-trips, include = TRUE}

## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Keep points associated with individual trips ----
## Filter the data to only keep the points associated with individual trips that
## were recognised as complete trips.
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Let's first check how many trips we record as Yes vs. No before filtering
head(trips,2)
## all locations associated with Return or not
table(trips$Returns)
## summary of trips associated with Return or not
totalTripsAll <- data.frame(trips) %>% group_by(tripID, Returns) %>% 
  summarise(count = n()) %>% 
  data.frame(.)
## view summary result
table(totalTripsAll$Returns)

## NOW, Filter to only include trips that return
trips.return.yes <- subset(trips, trips$Returns == "Yes" )
totalTripsYes <- data.frame(trips.return.yes) %>% group_by(tripID, Returns) %>% 
  summarise(count = n()) %>% 
  data.frame(.)
## view summary result
table(totalTripsYes$Returns)

## Filter for trips that do not reutrn
trips.return.no <- subset(trips, trips$Returns == "No" )
totalTripsNo <- data.frame(trips.return.no) %>% group_by(tripID, Returns) %>% 
  summarise(count = n()) %>% 
  data.frame(.)
## view summary result
table(totalTripsNo$Returns)

## CONSIDER and compare: total trips that returned vs. did not:
table(totalTripsYes$Returns)
table(totalTripsNo$Returns)

"Here, the user should consider if too many individual trips have been removed.
i.e. if you tracked 30 birds and you estimated to have approximately 3 trips 
recoreded per bird, then you would have a total of 90 trips. But it's likely that
on some trips, that not the entire trip was recorded (for multiple reasons).
Therefore, you might expect to rather have about 83 trips recorded across all
birds because for 7 trips data might not have indicated birds returned to the colony.
If you had a very high proportion of trips that did not return to the colony, then
it's likely that you have defined the parameters incorrectly for tripSplit and you
should reconsider better ecologically based estimates for these parameters. There
is of course the chance that there are other issues with your data."

```


### Review points associated with complete trips only

If you want to explore further the trips that were not considered to have returned, then use the object above, `trips.return.no`, to investigate the individual trips further. E.g. through individual plotting.

For our example, we have 339 complete trips and 23 incomplete trips. We continue to use only the complete trips.

```{r track-vis-ind-keep-complete-trips-choose, include = TRUE}

## rename the object to align better with further components of the script
trips <- trips.return.yes

```

## Sampling interval assessment

To implement track2KBA fully, you need data approximating an even sampling interval
i.e. location points must be regularly spaced in time.
Determine how "gappy" the tracking data is (time intervals between location data)
This is an important step for almost all tracking data analyses.
If your data is not filtered / cleaned correctly, results may be spurious.

```{r track-vis-ind-sampling-interval, include = TRUE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Check sampling interval ----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## data for summarising
head(data.frame(trips),2)
table(trips$Returns)

## Determine difference between consecutive timestamps 
## (NB: consecutive order of timestamps is critical here!)
## Doing this by tripID, not individual ID - change the group_by argument if needed
timeDiff <- trips %>% 
  data.frame() %>% 
  group_by(tripID) %>% 
  arrange(DateTime) %>% 
  mutate(delta_secs = as.numeric(difftime(DateTime, lag(DateTime, default = first(DateTime)), units = "secs"))) %>% 
  slice(2:n()) 

head(data.frame(timeDiff),2)
hist(timeDiff$delta_secs)

## plot histogram of timediff between all points
"This plot will take time depending on size of dataset!"
p4 <- ggplot(timeDiff , aes(delta_secs)) +
  geom_histogram(colour = "darkgrey", fill = "cyan", binwidth = 200)+
  theme(
    axis.text=element_text(size=14, color="black"),
    axis.title=element_text(size=16),
    panel.background=element_rect(fill="white", colour="black")) +
  ylab("n locations") + xlab("Time diff between locations (secs)")
p4

## Summarise results by tripID
SummaryTimeDiff <- timeDiff %>% 
  group_by(tripID) %>% 
  summarise(mean_timegap_secs = mean(delta_secs),
            median_timegap_secs = median(delta_secs),
            min_timegap_secs = min(delta_secs),
            max_timegap_secs = max(delta_secs)) %>%
  ## time in days
  mutate(max_timegap_days =  max_timegap_secs / 86400) %>% 
  mutate(max_timegap_days = round(max_timegap_days,2)) %>% 
  data.frame()

## View results
SummaryTimeDiff
head(SummaryTimeDiff)


```

### Sampling interval review

> Consider whether the sampling interval of your tracking data is appropriate
  for formally running the track2KBA functions. Remember, the time differences
  between each of your location points should be equal (or close enough to equal) 
  across all location points and individuals tracked. If the time difference
  between location points is not equal, the outputs you generate from track2KBA
  will not be valid because the underlying kernel density analysis implemented
  within the track2KBA functions will be invalid 
  (because you need points evenly spaced in time for this analysis to be valid).

Therefore, review the summary of your recorded sampling interval data:

```{r track-vis-ind-sampling-interval-review, include = TRUE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Review sampling interval ----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Average sampling interval of all data
## median of median time gaps in minutes
median(SummaryTimeDiff$median_timegap_secs)/60

## Sort data by maximum time gap first - then view.
## Consider if you have any outlier trips with massively different time gaps.
SummaryTimeDiff %>% arrange(-max_timegap_secs) %>% head(10)

## simple histogram 
hist(SummaryTimeDiff$max_timegap_days)

```

If you have trips where the maximum time gap in seconds (`max_timegap_secs`) is 
extremely different to the *median of median time gaps* in minutes, then it's likely you need to consider why this is the case for those trips.
- Did you specify tripSplit parameters incorrectly?
- Does the data require further cleaning in some other way?
- What else to consider

> NOTE: you should be aware of what the original pre-programmed sampling interval was. How do you results compare to this interval?

["CONSIDER: What is the best way to provide advice on appropriate time gap selection
for interpolation based on results above vs. comparison with intended sampling interval."]

## Interpolation

If you have gaps in your tracking data, you need to fill these gaps for the purpose of the track2KBA protocol. It's likely you will need to do this for many other tracking data analyses.

Broadly speaking, there are two key ways to fill the gaps in your tracking data, a process known as interpolation.

These two ways include:
- Simpler linear interpolation
- More advanced interpolation options that try account for where the animal could have moved (e.g. CRAWL)

> Typically, for flying seabirds, where gaps in tracking data are less likely because birds do not typically dive underwater for durations as long as diving seabirds, linear interpolation should serve as a suitable starting point.

> More advanced interpolation methods may be required for diving seabirds, or other diving marine predators.

### Interpolation pre-processing data

**Key considerations related to identifying IBAs / KBAs:** when identifying an IBA or KBA for seabirds using the track2KBA protocol, you effectively need information about the source population (typically the colony) and distribution data (tracking data). This means that not only can you identify a pelagic site from tracking data, but you can also consider an IBA/KBA for the colony itself and a possible at-sea buffer around the colony.

<br>

- Because you should typically consider identifying the at-sea buffer around the colony in addition to any potential pelagic / offshore sites supported by the tracking data, you can remove location points from the data within a suitable buffer distance.

<br>

- Removing trip start and end points near colony for the interpolation, especially if using more advanced methods like CRAWL, ALSO supports that the speed filters can focus on points at sea when you estimate birds should be moving, as opposed to trying to deal with sections of trips when the bird is actually stationary on land.

> CONSIDER: Appropriate choice of buffer distance in relation to identifying at-sea buffer IBAs for seabirds.

[consider better name for at-sea buffer IBAs]

[Should we apply relative at-sea buffer at the tripSplit step or later on. Later seems to make sense to me. But this also means we might remove what are considered invidual trips if we increase the buffer size.]

```{r track-vis-ind-buffer-points, include = TRUE}

##
length(unique(trips$tripID))

warning("Must update GitHub tutorial which specifies distance incorrectly")
## remove trip start and end points near colony - distance is in m (unlike innerBuff where distance was in km)
tracks <- trips[trips$ColDist > 3*1000, ]

##
length(unique(tracks$tripID))

```

## When to remove or salvage data for a tracked individual

[Examples / details to be added]

> In some cases, an entire track may be worth disregarding or trying to salvage. However, it often might be the case that only certain trips from the entire period an animal was tracked may be worth removing.

> Having split data from individual animal into unique trips let's review all the options for cleaning, removing, salvaging data from individual trips relating to tracked animals.

```{r track-vis-ind-save, include = TRUE}

## save updated file for next steps
save(tracks, file = "data-testing/tracking-data/Tracking_YESH_raw_step3.Rdata")

```

## Next steps: in next chapter

>FROM HERE: include speed filter and lintear interpolation options. Consider CRAWL options. Allow for comparison between two options. Build in steps that will loop interpolation over all individual trips.

> See the previous supporting R code: tracking_CleanAndPrepareData2_AllTracks and go to the animotum sections which comes first before linear. Actually want linear interpolation first.
