[["index.html", "Marine Megafauna Conservation Toolkit Preface", " Marine Megafauna Conservation Toolkit BirdLife International Partnership Preface "],["intro.html", "1 Introduction", " 1 Introduction You can label chapter and section titles using {#label} after them, e.g., we can reference Chapter 1. If you do not manually label them, there will be automatic labels anyway, e.g., Chapter ??. Figures and tables with captions will be placed in figure and table environments, respectively. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 1.1: Here is a nice figure! Reference a figure by its code chunk label with the fig: prefix, e.g., see Figure 1.1. Similarly, you can reference tables generated from knitr::kable(), e.g., see Table 1.1. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 1.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa You can write citations, too. For example, we are using the bookdown package [@R-bookdown] in this sample book, which was built on top of R Markdown and knitr [@xie2015]. "],["tracking-data-introduction.html", "2 Tracking data: Introduction 2.1 Introduction to animal tracking data considered in this toolkit 2.2 Lay introduction to GPS, PTT, GLS devices", " 2 Tracking data: Introduction This chapter was built with R version 4.2.2 (2022-10-31 ucrt) The chapter was last updated on 2023-03-30 2.1 Introduction to animal tracking data considered in this toolkit This toolkit focuses on the analysis of data primarily from GPS and PTT devices. Some of the analyses may be extended to data from GLS devices. For all devices, we encourage users to understand the limitations of each device and how these limitations can affect interpretation of animal movement patterns. For a general introduction into understanding animal movement patterns, we refer users to: animal movement references TBC For a general introduction into understanding seabird movement patterns, we refer users to: seabird movement references TBC For a general introduction into understanding GPS, PTT and GLS technologies, we refer users to: GPS, PTT, GLS references TBC 2.2 Lay introduction to GPS, PTT, GLS devices [Consider from MIRO board: Figure: Location data associated with different device types: GPS | PTT | GLS. Showcasing error associated with devices.] "],["tracking-data-sampling-strategy.html", "3 Tracking data: Sampling strategy 3.1 Sampling strategy when collecting animal tracking data for seabirds 3.2 How many birds should you track? 3.3 How many years of tracking data should you collect? 3.4 How many years of tracking data should you collect for IBA or KBA identification? 3.5 Which locations should you track animals from? 3.6 Sampling strategy general recommendations", " 3 Tracking data: Sampling strategy This chapter was built with R version 4.2.2 (2022-10-31 ucrt) The chapter was last updated on 2023-03-30 3.1 Sampling strategy when collecting animal tracking data for seabirds Animal tracking technology has evolved with respect to size and cost of devices. Hence, the opportunities for collecting tracking data have changed too. In the past - when devices were much larger and much more expensive - it was likely that few birds were tracked. Tracking typically occurred from sites that were more accessible than others, as opposed to sites specifically being chosen for their larger source populations. While this type of sampling strategy (selecting sites for accessibility) is often dictated by pragmatic choices needing to be made, or alternate research questions being addressed, outputs from these studies may not necessarily lend themselves well to the identification of globally important sites such as IBAs and KBAs. Researchers must take sampling strategy into account when considering the type of question they wish to answer in their studies. Of course, data collected from one study may be used in a different study in future. But the utility of such data being considered for retrospective analyses should be considered appropriately. 3.2 How many birds should you track? There is no precise answer to this question. The answer in part depends on what kind of question you are trying to answer about a particular species. If you are tracking a globally threatened species with an extremely small population size, or are tracking a species highly sensitive to devices being deployed on it, then a small number of individuals being tracked may be sufficient to identify where an important site might be. However, we suggest that at least 10 birds from a unique dataGroup are tracked before inferring movement patterns about a particular source population. dataGroup: learn more about how to define a dataGroup in the dataGroup chapter. 3.3 How many years of tracking data should you collect? Again, there is no precise answer to this question. Recent evidence, based on GPS tracking of 23 chick-rearing seabird species, suggests that: tracking chick-rearing seabirds across years improves the estimation of at-sea spatial distributions. However, in most cases the information gain is marginal. samples collected in only one or two years can be useful for the identification of important sites. of key importance when considering tracking data for questions related to area-based conservation is whether the sample of tracked individuals is representative at the population level. when only one or two years of tracking data are available for important site identification, using independent evidence to assess whether conditions were typical of the region and time of year is critical for interpretation of results. if conditions were atypical, then further years of sampling may be warranted. One to two years of tracking data may be sufficient to inform area-based conservation decisions. However, long-term studies will still be critical to inform how seabirds may respond to envrionmental perturbation. 3.4 How many years of tracking data should you collect for IBA or KBA identification? [See: KBA Guidelines. Discuss appropriate text with Charlotte] 3.5 Which locations should you track animals from? A number of factors may dictate which locations you track animals from. Broadly speaking, these factors may include: sites selected depending on the research question you wish to address sites selected owing to feasibility of accessing sites sites selected according to species known ecology, and hence ability to capture and deploy (and / or retrieve where necessary) devices on animals In the context of the marine toolkit, where identification of globally important marine sites is often linked to individuals tracked from a particular source location (i.e. the dataGroup): we advise investigators to track animals from source locations where those sites themselves would trigger relevant IBA or KBA criteria. [Further figure should be provided to better showcase sampling strategy] 3.6 Sampling strategy general recommendations In general, to support identification of an important site at sea from animal tracking data, we suggest the following: A minimum of 10 individual animals are tracked; all from the same source population Data from the 10 individual animals that are tracked should all represent data from the same life-cycle stage, within a given year, when it is expected that animals are moving in a similar manner to one another. (e.g. for penguins, you should have tracking information for all 10 individuals from within the chick-guard period) the dataGroup: [consider text here about the dataGroup] "],["tracking-data-load-data-into-r-and-visualise.html", "4 Tracking data: Load data into R and visualise 4.1 Description of the example dataset 4.2 Load packages 4.3 Input parameters for chapter tutorial 4.4 Storing, reading, and formatting raw tracking data 4.5 Load raw tracking data 4.6 Format data to match that of the Seabird Tracking Database 4.7 Review of the example data so far 4.8 Explore the tabular data 4.9 Review of summary output 4.10 Arrange data and remove duplicate entries 4.11 Visualise all the location data 4.12 Review of overall plot for all data points 4.13 Save all the location data as a shapefile 4.14 Visualise individual animal tracks", " 4 Tracking data: Load data into R and visualise This tutorial uses example data from a project led by the BirdLife International partner in Croatia: BIOM The citation for this data is: TBC The example data can be downloaded from: TBC - SBTD Analyses outlined in this chapter were performed in R version 4.2.2 (2022-10-31 ucrt) This chapter was last updated on 2023-03-30 4.1 Description of the example dataset Species tracked: Yelkouan Shearwater (Puffinus yelkouan) Life-cycle stage when birds were tracked: chick-rearing Site / source population birds tracked from: Lastovo SPA, Croatia Years birds were tracked over: 2019, 2020 Devices birds were tracked with: GPS Device model type: PathTrack nanoFix GPS/UHF transmitters (≤ 5.5 g) [Figure showcasing Lastovo SPA and source populations] 4.2 Load packages Load required R packages: If the package(s) fails to load, you will need to install the relevant package(s). ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## Load libraries -------------------------------------------------------------- ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## sf package for spatial data analyses (i.e. vector files such as points, lines, polygons) library(sf) ## Tidyverse for data manipulation library(tidyverse) ## ggplot2 for plotting opionts library(ggplot2) ## rnaturalearth package for geographic basemaps in R library(rnaturalearth) ## leaflet package for interactive maps in R library(leaflet) ## lubridate for date time library(lubridate) 4.3 Input parameters for chapter tutorial Here we define input parameters needed for sections of the code later in this tutorial. Depending on how your data is set up, you should not need to define any further input parameters. ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## Specify projections / store needed CRS definitions as variables ---- ## SEE: https://epsg.io/ ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## world - unprojected coordinates wgs84 &lt;- st_crs(&quot;EPSG:4326&quot;) ## Croatia - projected coordinates htrs96 &lt;- st_crs(&quot;EPSG:3765&quot;) 4.4 Storing, reading, and formatting raw tracking data 4.4.1 Storing raw tracking data The type of device you use will dictate what format your raw tracking data is stored in. Typically, we will work with .csv files. Good file management is critical when working with large tracking datasets. [As a guide, the following file structure can support efficient data management] 4.4.2 Reading raw tracking data into R / Rstudio Depending on your file structure, type of raw data, and size of your overall data, we recommend reading data into R in a way that produces a single data frame (or tibble) for all your data required for a specific analysis. [Example R code for reading in raw tracking data is provided in the Appendix] 4.4.3 Format of data Having data standardised into a common format greatly improves reproducible research, and also the ability for data to be used in other studies. The primary format we recommend is that of BirdLife International’s Seabird Tracking Database: - https://www.seabirdtracking.org/ We recognise, however, that this format may not be appropriate for all analyses. Nevertheless, we encourage users to standardise their data into a common format. This will facilitate the ease through which data can be reformatted when necessary for other analyses. [Decide on best way to show example datasets - either as screen shot images? Or as example data files? Or perhaps as both. Maybe just taking subsets of the data as required.] 4.5 Load raw tracking data Below, we load the raw tracking data obtained for Yelkouan Shearwaters. To see how this data was loaded into R originally, and merged to create a single data frame, see the example code in the Appendix. The load function supports loading various R file formats. Here we are loading an .Rdata file. The file was previously saved with the name of yelk. So when we load the file, an object called yelk will be loaded into the working environment in R. ## Load the example data for Yelkouan Shearwaters load(&quot;data-testing/tracking-data/Tracking_YESH_raw.Rdata&quot;) ## view the first two rows of data ## First view the data in tibble format head(yelk,2) ## # A tibble: 2 × 16 ## day month year hour minute second satell…¹ latit…² longi…³ altit…⁴ time_…⁵ ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 24 5 19 0 49 9 5 42.8 16.9 -1.5 2.91 ## 2 24 5 19 1 9 3 5 42.8 16.9 5.25 2.80 ## # … with 5 more variables: accuracy &lt;dbl&gt;, voltage &lt;dbl&gt;, colony_code &lt;chr&gt;, ## # bird_id &lt;chr&gt;, dttm &lt;dttm&gt;, and abbreviated variable names ¹​satellites, ## # ²​latitude, ³​longitude, ⁴​altitude, ⁵​time_offset ## Then view the data in data frame format head(data.frame(yelk),2) ## day month year hour minute second satellites latitude longitude altitude ## 1 24 5 19 0 49 9 5 42.81153 16.88553 -1.50 ## 2 24 5 19 1 9 3 5 42.81203 16.88691 5.25 ## time_offset accuracy voltage colony_code bird_id ## 1 2.910 4.70376e-07 4.12 Z 19_Tag17600_Z-9 ## 2 2.795 9.25368e-07 4.08 Z 19_Tag17600_Z-9 ## dttm ## 1 2019-05-24 00:49:09 ## 2 2019-05-24 01:09:03 tibble vs data frame: we don’t go into the specifics of these different data formats. The key message is that each provides a different way of interacting with, or viewing, data. Both are essentially a mechanism through which to work with tabular data. (i.e. data in rows and columns) 4.6 Format data to match that of the Seabird Tracking Database In the example dataset, you will notice that the data is not in the format of that relating to the seabird tracking database. We can reformat the data by extracting the relevant columns of information, and by adding in any information where it might be missing. ## First, add relevant columns of information to align with SBTD format ## the mutate functions allows you to add a new column of information. ## add the new columns and rename the object to a more standardised name. df_sbtd &lt;- yelk %&gt;% dplyr::mutate(dataset_id = &quot;tbc&quot;, scientific_name = &quot;Puffinus yelkouan&quot;, common_name = &quot;Yelkouan Shearwater&quot;, site_name = &quot;Lastovo SPA&quot;, lat_colony = &quot;tbc&quot;, lon_colony = &quot;tbc&quot;, device = &quot;GPS&quot;, age= &quot;adult&quot;, sex= &quot;unknown&quot;, breed_stage = &quot;chick-rearing&quot;, breed_status = &quot;breeding&quot;, argos_quality = NA, equinox = NA) ## Create the separate date and time columns to match the format of the SBTD, where ## these columns are provided separately df_sbtd &lt;- df_sbtd %&gt;% mutate(date_gmt = date(dttm), time_gmt = format(dttm, format = &quot;%H:%M:%S&quot;)) ## review the changes you have made (i.e. the new columns you have added) head(data.frame(df_sbtd),2) ## day month year hour minute second satellites latitude longitude altitude ## 1 24 5 19 0 49 9 5 42.81153 16.88553 -1.50 ## 2 24 5 19 1 9 3 5 42.81203 16.88691 5.25 ## time_offset accuracy voltage colony_code bird_id ## 1 2.910 4.70376e-07 4.12 Z 19_Tag17600_Z-9 ## 2 2.795 9.25368e-07 4.08 Z 19_Tag17600_Z-9 ## dttm dataset_id scientific_name common_name ## 1 2019-05-24 00:49:09 tbc Puffinus yelkouan Yelkouan Shearwater ## 2 2019-05-24 01:09:03 tbc Puffinus yelkouan Yelkouan Shearwater ## site_name lat_colony lon_colony device age sex breed_stage ## 1 Lastovo SPA tbc tbc GPS adult unknown chick-rearing ## 2 Lastovo SPA tbc tbc GPS adult unknown chick-rearing ## breed_status argos_quality equinox date_gmt time_gmt ## 1 breeding NA NA 2019-05-24 00:49:09 ## 2 breeding NA NA 2019-05-24 01:09:03 ## Now select all the relevant columns to align data with the format of the ## seabird tracking database. ## There are 21 columns of data in the format for the SBTD. ## Remember, when you use the select function, you can also rename columns simultaneously. df_sbtd &lt;- df_sbtd %&gt;% dplyr::select(dataset_id, scientific_name, common_name, site_name, ## below for example, we select the column ## called colony_code but rename it to colony_name colony_name = colony_code, lat_colony, lon_colony, device, bird_id = bird_id, track_id = bird_id, original_track_id = bird_id, age, sex, breed_stage, breed_status, date_gmt, time_gmt, latitude, longitude, argos_quality, equinox) ## review the changes again head(data.frame(df_sbtd),2) ## dataset_id scientific_name common_name site_name colony_name ## 1 tbc Puffinus yelkouan Yelkouan Shearwater Lastovo SPA Z ## 2 tbc Puffinus yelkouan Yelkouan Shearwater Lastovo SPA Z ## lat_colony lon_colony device bird_id track_id ## 1 tbc tbc GPS 19_Tag17600_Z-9 19_Tag17600_Z-9 ## 2 tbc tbc GPS 19_Tag17600_Z-9 19_Tag17600_Z-9 ## original_track_id age sex breed_stage breed_status date_gmt ## 1 19_Tag17600_Z-9 adult unknown chick-rearing breeding 2019-05-24 ## 2 19_Tag17600_Z-9 adult unknown chick-rearing breeding 2019-05-24 ## time_gmt latitude longitude argos_quality equinox ## 1 00:49:09 42.81153 16.88553 NA NA ## 2 01:09:03 42.81203 16.88691 NA NA 4.7 Review of the example data so far For the following columns, you may notice a few things: dataset_id is specified as tbc. This is because until data has been loaded into the SBTD, it will not have a unique dataset identification code that would relate to the dataset stored in the SBTD. lat_colony, lon_colony are specified as tbc, because we still need to define what the colony coordinates would be for each of locations birds were tagged from. bird_id, track_id, original_track_id, are all specified with the same code. This is because when data is formatted to align with the format of the SBTD: we have a code that relates to the bird that was tracked (bird_id) we have a SBTD unique code that relates to each trip undertaken by the bird, when multiple trips are recorded (track_id). Note though, it is often the case that users do not provide data which has been pre-split into unique trips. Therefore, it is often the case that all entries relating to track_id match that of bird_id. we have a user defined code that can relate to each trip undertaken by the bird. However, the same caveat in the case of track_id applies to this column of data too. argos_quality and equinox are both specified as NA. This is because our data relates to GPS data which does not have an argos_quality estimate (typical of PTT devices) or a measure relating to the equinox (typical of GLS devices). 4.8 Explore the tabular data Before you plot any data, it can be a good idea to broadly explore the data. While you might know which species you tracked, and from which colonies, and from which years, it can often be worth checking over these (and other) aspects of your data. Checking the data helps refresh your view on what data you have, and also helps you pick up any errors that may have arisen when inputting data. ## Reminder on what the data looks like so far head(data.frame(df_sbtd),2) ## dataset_id scientific_name common_name site_name colony_name ## 1 tbc Puffinus yelkouan Yelkouan Shearwater Lastovo SPA Z ## 2 tbc Puffinus yelkouan Yelkouan Shearwater Lastovo SPA Z ## lat_colony lon_colony device bird_id track_id ## 1 tbc tbc GPS 19_Tag17600_Z-9 19_Tag17600_Z-9 ## 2 tbc tbc GPS 19_Tag17600_Z-9 19_Tag17600_Z-9 ## original_track_id age sex breed_stage breed_status date_gmt ## 1 19_Tag17600_Z-9 adult unknown chick-rearing breeding 2019-05-24 ## 2 19_Tag17600_Z-9 adult unknown chick-rearing breeding 2019-05-24 ## time_gmt latitude longitude argos_quality equinox ## 1 00:49:09 42.81153 16.88553 NA NA ## 2 01:09:03 42.81203 16.88691 NA NA ## Review the main columns of data separately. This helps check for errors associated ## with data entry. E.g. perhaps you typed chick-rearing and CHICK-rearing. Because ## of the difference in lower-case vs. upper-case text, you might accidentally consider ## these as separate components of your dataset. ## the table function is useful to check the unique number of entries per unique input table(df_sbtd$scientific_name) ## ## Puffinus yelkouan ## 16703 table(df_sbtd$site_name) ## ## Lastovo SPA ## 16703 table(df_sbtd$colony_name) ## ## VM VR Z ## 3610 1739 11354 table(df_sbtd$breed_status) ## ## breeding ## 16703 table(df_sbtd$breed_stage) ## ## chick-rearing ## 16703 table(df_sbtd$age) ## ## adult ## 16703 table(df_sbtd$sex) ## ## unknown ## 16703 ## Summarise the data by species, site_name, colony_name, year, ## breed_status, breed_stage, age, sex. ## First we add a new year column by splitting the date column so we can get information about years df_overview &lt;- df_sbtd %&gt;% mutate(year = year(date_gmt)) %&gt;% ## then we group the data by relevant columns group_by(scientific_name, site_name, colony_name, year, breed_status, breed_stage, age, sex) %&gt;% ## then we continue to summarise by the distinct number of entries per group summarise(n_birds = n_distinct(bird_id), n_tracks = n_distinct(track_id), n_original_tracks = n_distinct(original_track_id)) ## review the summary output df_overview ## # A tibble: 4 × 11 ## # Groups: scientific_name, site_name, colony_name, year, breed_status, ## # breed_stage, age [4] ## scientific…¹ site_…² colon…³ year breed…⁴ breed…⁵ age sex n_birds n_tra…⁶ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Puffinus ye… Lastov… VM 2020 breedi… chick-… adult unkn… 8 8 ## 2 Puffinus ye… Lastov… VR 2021 breedi… chick-… adult unkn… 1 1 ## 3 Puffinus ye… Lastov… Z 2019 breedi… chick-… adult unkn… 19 19 ## 4 Puffinus ye… Lastov… Z 2020 breedi… chick-… adult unkn… 15 15 ## # … with 1 more variable: n_original_tracks &lt;int&gt;, and abbreviated variable ## # names ¹​scientific_name, ²​site_name, ³​colony_name, ⁴​breed_status, ## # ⁵​breed_stage, ⁶​n_tracks 4.9 Review of summary output From the summary output above we can see the following: scientific_name: we have tracking data from one species site_name: we have tracking data from one general site colony_name: we have tracking data from three colonies year: data comes from between 2019 and 2021 breed_status and breed_stage: all data relates to breeding birds in the chick-rearing life-cycle stage. age and sex: data is from adult birds of unknown sex n_birds, n_tracks, n_original_tracks: because n_birds = n_tracks, it indicates that: either the tracking data from each individual bird has not been separated into unique trips, or the tracking data from each individual bird is only representative of a single trip to sea 4.10 Arrange data and remove duplicate entries Once you have formatted your data into a standardised format and ensured that parts of your data is inputted correctly, it is also worth ensuring your data is ordered (arranged) correctly chronologically. An artifact of manipulating spatial data is that sometimes the data can become un-ordered with respect to time, or, given the way various devices interact with satellites, you can also end up with duplicated entries according to timestamps. This can be a first problem, causing your track to represent unrealistic movement patterns of the animal. We need to ensure our data is ordered correctly and also remove any duplicate timestamps. ## review your OVERALL data again head(data.frame(df_sbtd),2) ## dataset_id scientific_name common_name site_name colony_name ## 1 tbc Puffinus yelkouan Yelkouan Shearwater Lastovo SPA Z ## 2 tbc Puffinus yelkouan Yelkouan Shearwater Lastovo SPA Z ## lat_colony lon_colony device bird_id track_id ## 1 tbc tbc GPS 19_Tag17600_Z-9 19_Tag17600_Z-9 ## 2 tbc tbc GPS 19_Tag17600_Z-9 19_Tag17600_Z-9 ## original_track_id age sex breed_stage breed_status date_gmt ## 1 19_Tag17600_Z-9 adult unknown chick-rearing breeding 2019-05-24 ## 2 19_Tag17600_Z-9 adult unknown chick-rearing breeding 2019-05-24 ## time_gmt latitude longitude argos_quality equinox ## 1 00:49:09 42.81153 16.88553 NA NA ## 2 01:09:03 42.81203 16.88691 NA NA ## merge the date and time columns df_sbtd$dttm &lt;- with(df_sbtd, ymd(date_gmt) + hms(time_gmt)) ## first check how many duplicate entries you may have. If there are many, it ## is worth exploring your data further to understand why. n_duplicates &lt;- df_sbtd %&gt;% group_by(bird_id, track_id) %&gt;% arrange(dttm) %&gt;% dplyr::filter(duplicated(dttm) == T) ## review how many duplicate entries you may have. Print the message: print(paste(&quot;you have &quot;,nrow(n_duplicates), &quot; duplicate records in a dataset of &quot;, nrow(df_sbtd), &quot; records.&quot;, sep =&quot;&quot;)) ## [1] &quot;you have 11 duplicate records in a dataset of 16703 records.&quot; ## remove duplicates entries if no further exploration is deemed necessary df_sbtd &lt;- df_sbtd %&gt;% ## first group data by individual animals and unique track_ids group_by(bird_id, track_id) %&gt;% ## then arrange by timestamp arrange(dttm) %&gt;% ## then if a timestamp is duplicated (TRUE), then don&#39;t select this data entry. ## only select entries where timestamps are not duplicated (i.e. FALSE) dplyr::filter(duplicated(dttm) == F) 4.11 Visualise all the location data Using the leaflet package in R, you can easily visualise your tracking data interactively within RStudio. What should you look for when visualising the raw data? * Are your locations in realistic places? * Have you perhaps mixed up the latitude and longitude columns? * Does your data cross the international date line? Do you know how to deal with this? * Will you need to remove sections of the data that do not represent a time when the animal was tagged? (e.g. perhaps you set the device to start recording locations before deploying on the animal. So the tag might have recorded while you were travelling to the deployment location. Therefore, removing these sections of the track will facilitate your overall analysis.) ## review your OVERALL data again head(data.frame(df_sbtd),2) ## dataset_id scientific_name common_name site_name colony_name ## 1 tbc Puffinus yelkouan Yelkouan Shearwater Lastovo SPA Z ## 2 tbc Puffinus yelkouan Yelkouan Shearwater Lastovo SPA Z ## lat_colony lon_colony device bird_id track_id ## 1 tbc tbc GPS 19_Tag17652_Z-2 19_Tag17652_Z-2 ## 2 tbc tbc GPS 19_Tag17652_Z-2 19_Tag17652_Z-2 ## original_track_id age sex breed_stage breed_status date_gmt ## 1 19_Tag17652_Z-2 adult unknown chick-rearing breeding 2019-05-01 ## 2 19_Tag17652_Z-2 adult unknown chick-rearing breeding 2019-05-01 ## time_gmt latitude longitude argos_quality equinox dttm ## 1 21:40:41 42.81508 16.89058 NA NA 2019-05-01 21:40:41 ## 2 22:00:41 42.83751 16.89750 NA NA 2019-05-01 22:00:41 ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## visualise all data ---- ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## number of datapoints nrow(df_sbtd) ## [1] 16692 ## interactive plot map.alldata &lt;- leaflet() %&gt;% ## start leaflet plot ## select background imagery addProviderTiles(providers$Esri.WorldImagery, group = &quot;World Imagery&quot;) %&gt;% ## plot the points. Note: leaflet automatically finds lon / lat colonies addCircleMarkers(data = df_sbtd, ## size of points radius = 3, ## colour of points fillColor = &quot;cyan&quot;, ## transparency of points fillOpacity = 0.5, ## set stroke = F to remove borders around points stroke = F) ## generate the plot map.alldata 4.12 Review of overall plot for all data points Based on the interactive plot, you can see that generally the data looks good. All the locations are in the Adriatic Sea area (something we would anticipate based on what we know about Yelkouan Shearwaters breeding in Croatia). We can conclude the following: Locations appear to be in realistic places. It’s unlikely that we have mixed up the latitude and longitude columns. The data does not cross the international date line. Regarding removing sections of the data that do not represent a time when the animal was tagged: Later filtering steps may remove these parts of the track if locations are near the vicinity of the colony (see details of the tripSplit() function. However, if there are broader location data associated with these types of locations, you will need to remove these sections of the track. 4.13 Save all the location data as a shapefile Visualising all the location data in R can be a simpler starting point. You may also want to save this data as a shapefile (.shp) for viewing in GIS software such as QGIS or ArcGIS. Note: saving all data as a single shapefile can be a memory intensive task (i.e. if you have a lot of data, then your computer might take a long time to save the file, or the file will be big and slow to work with) ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## First add a simplified unique id and create the sf spatial object ---- ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## Review data head(data.frame(df_sbtd),2) ## dataset_id scientific_name common_name site_name colony_name ## 1 tbc Puffinus yelkouan Yelkouan Shearwater Lastovo SPA Z ## 2 tbc Puffinus yelkouan Yelkouan Shearwater Lastovo SPA Z ## lat_colony lon_colony device bird_id track_id ## 1 tbc tbc GPS 19_Tag17652_Z-2 19_Tag17652_Z-2 ## 2 tbc tbc GPS 19_Tag17652_Z-2 19_Tag17652_Z-2 ## original_track_id age sex breed_stage breed_status date_gmt ## 1 19_Tag17652_Z-2 adult unknown chick-rearing breeding 2019-05-01 ## 2 19_Tag17652_Z-2 adult unknown chick-rearing breeding 2019-05-01 ## time_gmt latitude longitude argos_quality equinox dttm ## 1 21:40:41 42.81508 16.89058 NA NA 2019-05-01 21:40:41 ## 2 22:00:41 42.83751 16.89750 NA NA 2019-05-01 22:00:41 ## add a simplified animal ID column - a simple number for each unique animal tracked df_sbtd$bird_id_num &lt;- as.numeric(factor(df_sbtd$bird_id, levels = unique(df_sbtd$bird_id))) ## Review data again (tail function prints the end of the dataframe so you can ## check if the last unique number matches the number of animals you tracked.) head(data.frame(df_sbtd),2) ## dataset_id scientific_name common_name site_name colony_name ## 1 tbc Puffinus yelkouan Yelkouan Shearwater Lastovo SPA Z ## 2 tbc Puffinus yelkouan Yelkouan Shearwater Lastovo SPA Z ## lat_colony lon_colony device bird_id track_id ## 1 tbc tbc GPS 19_Tag17652_Z-2 19_Tag17652_Z-2 ## 2 tbc tbc GPS 19_Tag17652_Z-2 19_Tag17652_Z-2 ## original_track_id age sex breed_stage breed_status date_gmt ## 1 19_Tag17652_Z-2 adult unknown chick-rearing breeding 2019-05-01 ## 2 19_Tag17652_Z-2 adult unknown chick-rearing breeding 2019-05-01 ## time_gmt latitude longitude argos_quality equinox dttm ## 1 21:40:41 42.81508 16.89058 NA NA 2019-05-01 21:40:41 ## 2 22:00:41 42.83751 16.89750 NA NA 2019-05-01 22:00:41 ## bird_id_num ## 1 1 ## 2 1 tail(data.frame(df_sbtd),2) ## dataset_id scientific_name common_name site_name colony_name ## 16691 tbc Puffinus yelkouan Yelkouan Shearwater Lastovo SPA VR ## 16692 tbc Puffinus yelkouan Yelkouan Shearwater Lastovo SPA VR ## lat_colony lon_colony device bird_id track_id ## 16691 tbc tbc GPS 21_Tag41220_VR-1 21_Tag41220_VR-1 ## 16692 tbc tbc GPS 21_Tag41220_VR-1 21_Tag41220_VR-1 ## original_track_id age sex breed_stage breed_status date_gmt ## 16691 21_Tag41220_VR-1 adult unknown chick-rearing breeding 2021-07-09 ## 16692 21_Tag41220_VR-1 adult unknown chick-rearing breeding 2021-07-09 ## time_gmt latitude longitude argos_quality equinox dttm ## 16691 18:10:17 42.80311 16.78880 NA NA 2021-07-09 18:10:17 ## 16692 19:10:14 42.80255 16.79699 NA NA 2021-07-09 19:10:14 ## bird_id_num ## 16691 43 ## 16692 43 ## create the sf spatial object df_sbtd_sf &lt;- df_sbtd %&gt;% ## first create new columns of lon and lat again so you keep this location ## information in tabular format. mutate(lon_device = longitude, lat_device = latitude) %&gt;% ## then convert object to sf spatial object st_as_sf(coords = c(&quot;longitude&quot;, &quot;latitude&quot;), crs = wgs84) ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## Save raw tracking data as shapefile for viewing in GIS software ---- ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## Option allows for multispecies data ## Or the loop will only run once if you have single species data for(i in unique(df_sbtd$scientific_name)){ ## subset the data taking the track information for each unique species temp_species &lt;- df_sbtd_sf %&gt;% dplyr::filter(scientific_name == unique(df_sbtd$scientific_name)[i]) ## create new folder within current working directory where you will save data ## first create the name of the species and the file path you need ## also use gsub to replace spaces within character strings (words) with a &quot;-&quot; species_name &lt;- gsub(&quot; &quot;, &quot;-&quot;, temp_species$scientific_name[1]) ## print the name for checking print(species_name) ## then create the new folder within current working directory path_to_folder &lt;- paste(&quot;./data-testing/tracking-data/&quot;, species_name, sep=&quot;&quot;) ## print the file path name for checking print(path_to_folder) ## Check if folder exists, and if it does not, then make a new folder if (!file.exists(path_to_folder)) { # If it does not exist, create a new folder dir.create(path_to_folder) print(paste(&quot;Created folder:&quot;, path_to_folder)) } else { # do nothing, but let us know the folder exists already print(paste(&quot;Folder already exists:&quot;, path_to_folder)) } ## write the spatial data as a shapefile ## NOTE: For some GIS software, column names will be abbreviated upon saving ## NOTE: If you have very long file paths, this operation may fail. One solution ## is to save the shapefile elsewhere. Another solution is to instead save the file ## as a geopackage (.gpkg): simply replace the .shp text below with .gpkg st_write(df_sbtd_sf, paste(path_to_folder, &quot;/&quot;, species_name, &quot;_AllTracks.shp&quot;, sep = &quot;&quot;), delete_layer = TRUE) ## remove the temporary file at the end of each loop rm(temp_species) } ## [1] NA ## [1] &quot;./data-testing/tracking-data/NA&quot; ## [1] &quot;Created folder: ./data-testing/tracking-data/NA&quot; ## Writing layer `NA_AllTracks&#39; to data source ## `./data-testing/tracking-data/NA/NA_AllTracks.shp&#39; using driver `ESRI Shapefile&#39; ## Writing 16692 features with 23 fields and geometry type Point. 4.14 Visualise individual animal tracks Once you have reviewed the overall status of the tracking data you collected, it can be worth assessing the tracks of individual animals. This can give you a better idea of the quality of the data for each individual. Visualising tracking data from individual animals can help you understand which data you might remove, or which data you might try and salvage. Depending on the amount of data you have, you can often initially a perform a static exploration of tracks from each individual (i.e. a simple plot of tracks from each individual), followed by an interactive exploration of tracks from all individuals, or only data from those individuals where interactive exploration is deemed necessary. Below, outlines options for visualising individual animal tracks. "],["seaward-extension-introduction.html", "5 Seaward Extension Introduction", " 5 Seaward Extension Introduction This document was last updated on 2023-03-30 This chapter provides guidance and code for delineating a seaward extension boundary from a colony of breeding seabirds. SEAWARD EXTENSION DEFINITION: These are marine areas immediately surrounding seabird breeding colonies. The areas are typically used for ecologically relevant behaviours such as rafting, preening, bathing, foraging or transiting between foraging trips, depending on a species. This tutorial uses the example data for Adelie Penguins. For information on the original study, see Handley et al. 2021 Marine Important Bird and Biodiversity Areas for Penguins in Antarctica, Targets for Conservation Action. Frontiers in Marine Science 7: 602972. https://doi.org/10.3389/fmars.2020.602972 While this tutorial is designed to allow minimal input from the user, users should understand the consequence of choices to input parameters while using the functions provided. What does this tutorial cover: Creating a suitable background raster (grid file) for use in the seaward extension method Producing a raster density grid and a polygon site boundary output for a seabird colony Producing raster density grids and polygon site boundaries outputs for a multiple seabird colonies and combine them to produce a stack final output. Inputs to this tutorial: Polygon (shapefile) of land Seabird colony location(s) (latitude and longitude) Radius around the colony (distance in km) Colony size(s) (number of breeding pairs) [Link to input data csv template] Guidance for inputs: Polygon of land (shapefile) The resolution of this file will impact the final results, so it needs to be sufficiently fine scale compared to the scale of distance used in the method. Shapefiles can be downloaded from https://gadm.org/data.html [Also r natural earth?] Seabird colony location (latitude and longitude) The accuracy of the location will impact the results, so it is recommended to check the location before running the method. For island colonies, if the colony covers the entire island, the centre of the island is suitable. If not, it is better to use a location on the correct side of the island. Radius around the colony (distance in km) [Possible distances: maxium, mean maximum, mean] [Could be from tracking (e.g. if sample size is too small to use track2KBA)] [Could be informed by at sea surveys?] Colony size (number of breeding pairs) Could also use Apparently Occupied Sites/Nests If the count is a range, could use mean. [Could also run for upper and lower estimate to include uncertainty] Output(s) from this tutorial, can be used to: assess data against relevant criteria, such as: IBA criteria: http://datazone.birdlife.org/site/ibacriteria KBA criteria: https://www.keybiodiversityareas.org/working-with-kbas/proposing-updating/criteria or, for identification of sites from animal tracking data to be used in alternate spatial planning exercises. "],["seaward-extensions-1-create-background-raster.html", "6 Seaward Extensions 1: Create Background Raster 6.1 Fill in raster values with land polygon basemap 6.2 Save the raster for use in the next section", " 6 Seaward Extensions 1: Create Background Raster This analysis was performed in R version 4.2.2 (2022-10-31 ucrt) This document was last updated on 2023-03-30 What does this section cover: Creating a raster (grid) that can be used for delineation of a seaward extension boundary from a colony of breeding seabirds. This raster will: Have a specified cell size (resolution). Cover the location of the colony or colonies with a buffer greater than the maximum radius distance. Specify cells at either marine or terrestrial (ice can be classified as terrestrial). This is the required input for the tutorials on how to produce outputs for a single seabird colony [link to 2] and multiple seabird colonies [link to 3]. Load required R packages: If the packages fail to load, you will need to install them. ## Load libraries #### #install.packages(&quot;sf&quot;) #install.packages(&quot;terra&quot;) library(sf) library(terra) Supply input data [For Marine Toolkit, need to provide guidance on choice of resolution. Currently, 5km aligned with same scale as the Critchley et al. 2018 paper.] The shapefile is not provide in the github repository as the file size was too large. The file can be downloaded here: https://data.bas.ac.uk/collections/e74543c0-4c4e-4b41-aa33-5bb2f67df389/ Alternatively, the output is provided, so this can be used directly in the next section. ## Colony location latitude &lt;- -60.683 longitude &lt;- -45.644 ## Land polygon basemap &lt;- read_sf(paste0(wd,&quot;/data-input-files-bookdown/Coastline_high_res_polygon_v7.1&quot;)) ## Maximum colony radius distance (m) max_colony_radius &lt;- 149000 ## Specified resolution of grid cell (m) grid_res &lt;- 5000 Format colony locations as spatial objects #format colony location as dataframe df &lt;- data.frame(cbind(latitude,longitude)) #Set coordinate reference system (CRS) for colony locations col_locs &lt;- st_as_sf(df,coords = c(&quot;longitude&quot;,&quot;latitude&quot;), crs = 4326) #If needed, convert colony data to basemap projection if(st_crs(col_locs) != st_crs(basemap)){ col_locs_proj &lt;- st_transform(col_locs, crs = st_crs(basemap)) } else { col_locs_proj &lt;- col_locs } Create raster #First set a buffer (m) around the colony/colonies + the resolution of the grid to make sure the grid is large enough. raster_buffer &lt;- max_colony_radius + grid_res #Find the extent of the colony locations bounds &lt;- st_bbox(col_locs_proj) #Create the blank raster grid with the crs of the land polygon ras &lt;- terra::rast(xmin = bounds[[1]] - raster_buffer, ymin = bounds[[2]] - raster_buffer, xmax = bounds[[3]] + raster_buffer, ymax = bounds[[4]] + raster_buffer, resolution = grid_res, crs = st_crs(basemap)$wkt) 6.1 Fill in raster values with land polygon basemap Convert the basemap, currently in polygon format, to a raster and then overlay with the blank raster NOTE: Operation will take time depending on size of polygon data and detail of borders. i.e. Higher resolution maps take longer to process. basemap_vector &lt;- vect(basemap) mask &lt;- terra::rasterize(basemap_vector, ras) ras &lt;- is.na(mask) ras[ras==0] &lt;- 2 plot(ras) #plot(st_geometry(col_locs_proj), pch = 19, col = &quot;blue&quot;, add = T) 6.2 Save the raster for use in the next section terra::writeRaster(ras,paste0(wd,&quot;/data-input-files-bookdown/seaward-ext-background-raster-single.tif&quot;), overwrite=T) "],["seaward-extensions-1-create-background-raster-1.html", "7 Seaward Extensions 1: Create Background Raster 7.1 Fill in raster values with land polygon basemap 7.2 Save the raster for use in the next section", " 7 Seaward Extensions 1: Create Background Raster This analysis was performed in R version 4.2.2 (2022-10-31 ucrt) This document was last updated on 2023-03-30 What does this section cover: Creating a raster (grid) that can be used for delineation of a seaward extension boundary from a colony of breeding seabirds. This raster will: Have a specified cell size (resolution). Cover the location of the colony or colonies with a buffer greater than the maximum radius distance. Specify cells at either marine or terrestrial (ice can be classified as terrestrial). This is the required input for the tutorials on how to produce outputs for a single seabird colony [link to 2] and multiple seabird colonies [link to 3]. Load required R packages: If the packages fail to load, you will need to install them. ## Load libraries #### #install.packages(&quot;sf&quot;) #install.packages(&quot;terra&quot;) library(sf) library(terra) Supply input data [For Marine Toolkit, need to provide guidance on choice of resolution. Currently, 5km aligned with same scale as the Critchley et al. 2018 paper.] The shapefile is not provide in the github repository as the file size was too large. The file can be downloaded here: https://data.bas.ac.uk/collections/e74543c0-4c4e-4b41-aa33-5bb2f67df389/ Alternatively, the output is provided, so this can be used directly in the next section. ## Colony data: location, abundance estimate df &lt;- read.csv(paste0(wd,&quot;/data-input-files-bookdown/AdeliePenguin_example_dataset.csv&quot;)) head(df) ## colony_name colony_size colony_size_min colony_size_max latitude ## 1 Acuna Island 3079 1880 3079 -60.7612 ## 2 Adams Island 425 76 425 -66.5459 ## 3 Cape Adare 428516 169200 428516 -71.3063 ## 4 Akarui Point 106 106 211 -68.4999 ## 5 Alasheyev Bight 1080 1080 1080 -67.6540 ## 6 Ambush Bay 17621 17621 17621 -63.1840 ## longitude ## 1 -44.6370 ## 2 92.5486 ## 3 170.1999 ## 4 41.3901 ## 5 46.1090 ## 6 -55.3930 ## Land polygon basemap &lt;- read_sf(paste0(wd,&quot;/data-input-files-bookdown/Coastline_high_res_polygon_v7.1&quot;)) ## Maximum colony radius distance (m) max_colony_radius &lt;- 149000 ## Specified resolution of grid cell (m) grid_res &lt;- 5000 Format colony locations as spatial objects #Set coordinate reference system (CRS) for colony locations col_locs &lt;- st_as_sf(df,coords = c(&quot;longitude&quot;,&quot;latitude&quot;), crs = 4326) #If needed, convert colony data to basemap projection if(st_crs(col_locs) != st_crs(basemap)){ col_locs_proj &lt;- st_transform(col_locs, crs = st_crs(basemap)) } else { col_locs_proj &lt;- col_locs } #Plot to check plot(st_geometry(col_locs_proj), pch = 19, col = &quot;blue&quot;) Create raster #First set a buffer (m) around the colony/colonies + the resolution of the grid to make sure the grid is large enough. raster_buffer &lt;- max_colony_radius + grid_res #Find the extent of the colony locations bounds &lt;- st_bbox(col_locs_proj) #Create the blank raster grid with the crs of the land polygon ras &lt;- terra::rast(xmin = bounds[[1]] - raster_buffer, ymin = bounds[[2]] - raster_buffer, xmax = bounds[[3]] + raster_buffer, ymax = bounds[[4]] + raster_buffer, resolution = grid_res, crs = st_crs(basemap)$wkt) 7.1 Fill in raster values with land polygon basemap Convert the basemap, currently in polygon format, to a raster and then overlay with the blank raster NOTE: Operation will take time depending on size of polygon data and detail of borders. i.e. Higher resolution maps take longer to process. basemap_vector &lt;- vect(basemap) mask &lt;- terra::rasterize(basemap_vector, ras) ras &lt;- is.na(mask) ras[ras==0] &lt;- 2 plot(ras) #plot(st_geometry(col_locs_proj), pch = 19, col = &quot;blue&quot;, add = T) 7.2 Save the raster for use in the next section terra::writeRaster(ras,paste0(wd,&quot;/data-input-files-bookdown/seaward-ext-background-raster.tif&quot;), overwrite=T) "],["track2kba-guidance.html", "8 Track2KBA Guidance 8.1 Load packages 8.2 Download example data and format 8.3 Quick plot all data 8.4 tripSplit() 8.5 tripSummary() 8.6 projectTracks() 8.7 estSpaceUse() 8.8 Review smoothing 8.9 repAssess() 8.10 findSite()", " 8 Track2KBA Guidance This tutorial uses the example data for Masked Boobies associated with the track2KBA GitHub account: https://github.com/BirdLifeInternational/track2kba Supported by the manuscript: Beal et al. (2021). track2KBA: An R package for identifying important sites for biodiversity from tracking data. Methods in Ecology and Evolution. The tutorial aims to further explain what the functions are doing and acts as a guide for inexperienced users. Users should consult this tutorial in conjunction with the 2021 manuscript, supplementary material and GitHub account. While track2KBA is designed to allow minimal input from the user, users should understand the consequence of choices to input parameters while using the functions provided within track2KBA. What does this tutorial cover: Overview of the Track2KBA R package Summary of the Track2KBA scientific paper https://doi.org/10.1111/2041-210X.13713 Incorporating further details from the Track2KBA paper supplementary material Incorporating details from the supporting Track2KBA GitHub tutorial https://github.com/BirdLifeInternational/track2kba Output(s) from this script, can be used to: assess data against relevant criteria, such as: IBA criteria: http://datazone.birdlife.org/site/ibacriteria KBA criteria: https://www.keybiodiversityareas.org/working-with-kbas/proposing-updating/criteria or, for identification of sites from animal tracking data to be used in alternate spatial planning exercises. This analysis was performed in R version 4.2.2 (2022-10-31 ucrt) This document was last updated on 2023-03-30 8.1 Load packages Load required R packages: If the packages fail to load, you will need to install the relevant packages. ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## Load libraries -------------------------------------------------------------- ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ library(track2KBA) library(tidyverse) library(readxl) library(sf) library(xlsx) library(sp) library(gridExtra) library(viridis) Before you use track2KBA to identify a final site for assessmenent you must consider the following: The dataGroup: Does your data sufficiently represent a unique dataGroup? See guidance. Cleaned data: Has your tracking data been cleaned sufficiently? I.e. have you removed likely incorrect locations from your tracking data? Regularised data: Does your tracking data represent locations evenly sampled in time? To regularise your tracking data so locations are evenly sampled in time, you may need to interpolate your tracking data. The typical options we consider are interpolation via linear interpolation, or the more advanced method of interpolation via “CRAWL”. Load example data available with the manuscript Example data from Masked Boobies during the breeding period. Birds during this time are typically exhibiting central place foraging behaviour. Consider: How should your data be formatted? You should have a dataframe which has at least five columns relating to: “ID” of the animal(s) you tracked further details tbc 8.2 Download example data and format ## Load the data data(boobies) ## view the first two rows of the data head(boobies,2) ## track_id date_gmt time_gmt longitude latitude lon_colony lat_colony ## 1 69302 2012-07-22 04:17:15 -5.72638 -16.00711 -5.73 -16.01 ## 2 69302 2012-07-22 04:28:57 -5.72642 -16.00716 -5.73 -16.01 ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## track2KBA::formatFields() ---- ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## Format the key data fields to the standard used in track2KBA dataGroup &lt;- formatFields( dataGroup = boobies, fieldID = &quot;track_id&quot;, fieldDate = &quot;date_gmt&quot;, fieldTime = &quot;time_gmt&quot;, fieldLon = &quot;longitude&quot;, fieldLat = &quot;latitude&quot; ) ## review the outputs - first what the new data looks like head(dataGroup,2) ## ID date_gmt time_gmt Longitude Latitude lon_colony lat_colony ## 1 69302 2012-07-22 04:17:15 -5.72638 -16.00711 -5.73 -16.01 ## 2 69302 2012-07-22 04:28:57 -5.72642 -16.00716 -5.73 -16.01 ## DateTime ## 1 2012-07-22 04:17:15 ## 2 2012-07-22 04:28:57 ## review the outputs - then details of each column (i.e. vector) class str(dataGroup) ## &#39;data.frame&#39;: 178006 obs. of 8 variables: ## $ ID : chr &quot;69302&quot; &quot;69302&quot; &quot;69302&quot; &quot;69302&quot; ... ## $ date_gmt : chr &quot;2012-07-22&quot; &quot;2012-07-22&quot; &quot;2012-07-21&quot; &quot;2012-07-21&quot; ... ## $ time_gmt : chr &quot;04:17:15&quot; &quot;04:28:57&quot; &quot;13:04:33&quot; &quot;13:18:24&quot; ... ## $ Longitude : num -5.73 -5.73 -5.73 -5.73 -5.73 ... ## $ Latitude : num -16 -16 -16 -16 -16 ... ## $ lon_colony: num -5.73 -5.73 -5.73 -5.73 -5.73 -5.73 -5.73 -5.73 -5.73 -5.73 ... ## $ lat_colony: num -16 -16 -16 -16 -16 ... ## $ DateTime : POSIXct, format: &quot;2012-07-22 04:17:15&quot; &quot;2012-07-22 04:28:57&quot; ... ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; 8.3 Quick plot all data Simple plot of all the data for a quick review: ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## view all data ---- ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## quick plot of all data for a quick overview dataGroup.plot &lt;- st_as_sf(dataGroup, coords = c(&quot;Longitude&quot;, &quot;Latitude&quot;), crs=4326) # 4326 = geographic WGS84 plot(st_geometry(dataGroup.plot), cex = 0.5, pch = 1) ## number of datapoints nrow(dataGroup) ## [1] 178006 8.4 tripSplit() Set up some of the input parameters needed for the tripSplit() function ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## Define colony ---- ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## example relates to a seabird during the breeding season, when the species ## is known to be a central place forager, therefore, define the colony position colony &lt;- dataGroup %&gt;% summarise( Longitude = first(Longitude), Latitude = first(Latitude) ) The tripSplit() function If your data does not relate to a central place forager (CPF), OR a time when an animal may be exhibiting central place foraging behaviours, then skip this section and those relating to CPF data This step is often very useful to help automate the removal of location points on land, or near the vicinty of a colony. We don’t want these extra points to bias our interpretation of the data. ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## tripSplit() ---- ## Input is a &#39;data.frame&#39; of tracking data and the central-place location. ## Output is a &#39;SpatialPointsDataFrame&#39;. trips &lt;- tripSplit( dataGroup = dataGroup, colony = colony, innerBuff = 3, # km - defines distance an animal must travel to count as trip started returnBuff = 10, # km - defines distance an animal must be from the colony to have returned and thus completed a trip duration = 1, # hours - defines time an animal must have travelled away from the colony to count as a trip. helps remove glitches in data or very short trips that were likely not foraging trips. rmNonTrip = TRUE # If true - points not associated with a trip will be removed ) ## Review data after tripSplit() head(trips,2) ## ID date_gmt time_gmt Longitude Latitude lon_colony lat_colony ## 706 69302 2012-07-22 07:52:11 -5.69104 -16.00650 -5.73 -16.01 ## 707 69302 2012-07-22 07:53:50 -5.68132 -16.00096 -5.73 -16.01 ## DateTime tripID X Y Returns StartsOut ColDist ## 706 2012-07-22 07:52:11 69302_01 -5.69104 -16.00650 Yes 3783.071 ## 707 2012-07-22 07:53:50 69302_01 -5.68132 -16.00096 Yes 4870.651 ## Assess number of points associated with a trip ## Yes: indicates a point is associated with a trip ## No: not associated with a trip ## If you specified rmNonTrip = FALSE above, then you will also get points (data) relating to the locations that would be filtered out from the tripSplit function table(trips$Returns) ## ## No Yes ## 1733 26717 ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## mapTrips() ---- ## view data after splitting into trips ---- ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## plot quick overview of trips recorded for individual birds mapTrips(trips = trips, colony = colony) 8.5 tripSummary() Summarise the tracking data using the tripSummary() function: ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## Filter and summary of number of trips after splitting tracks ---- ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## Before summarizing the trip movements, using tripSummary(). ## First, we can filter out data from trips that did not return to the vicinity ## of the colony (i.e. within returnBuff), so they don&#39;t skew the estimates. ## Let&#39;s also check how many trips we record as Yes vs. No before filtering ## Instead of looking at points associated with an invidual trip, looked at how ## many uniqu trips you have across all individuals. i.e. the total number of trips ## represented by each time an animal departed and returned to the colony ## summarise the data totalTripsAll &lt;- data.frame(trips) %&gt;% group_by(tripID, Returns) %&gt;% summarise(count = n()) %&gt;% data.frame(.) ## inspect the total number of unique trips table(totalTripsAll$Returns) ## ## No Yes ## 2 213 ## Filter to only include trips that return trips &lt;- subset(trips, trips$Returns == &quot;Yes&quot; ) ## review that you have only chosen trips that return totalTripsYes &lt;- data.frame(trips) %&gt;% group_by(tripID, Returns) %&gt;% summarise(count = n()) %&gt;% data.frame(.) ## inspect total number of unique trips table(totalTripsYes$Returns) ## ## Yes ## 213 ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## tripSummary() ---- ## Rough summary of tracking data for complete trips ---- ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ sumTrips &lt;- tripSummary(trips = trips, colony = colony) ## Check you only have complete trips here (if that is what you are aiming for) table(sumTrips$complete) ## ## complete trip ## 213 ## filter for only complete trips if needed #sumTrips &lt;- sumTrips %&gt;% dplyr::filter(complete= &quot;complete trip&quot;) ## view output head(sumTrips ,10) ## # A tibble: 10 × 10 ## # Groups: ID [4] ## ID tripID n_locs departure return durat…¹ total…² ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 69302 69302_01 274 2012-07-22 07:52:11 2012-07-22 16:11:03 8.31 207. ## 2 69302 69302_02 124 2012-07-23 12:26:22 2012-07-23 15:54:05 3.46 111. ## 3 69302 69302_03 138 2012-07-25 08:30:53 2012-07-25 12:22:53 3.87 116. ## 4 69305 69305_01 71 2013-08-22 13:08:15 2013-08-22 15:10:59 2.05 91.6 ## 5 69306 69306_01 37 2014-01-06 16:28:42 2014-01-06 17:32:11 1.06 46.2 ## 6 69306 69306_02 83 2014-01-07 14:48:24 2014-01-07 17:10:21 2.37 114. ## 7 69306 69306_03 129 2014-01-08 14:25:11 2014-01-08 17:55:22 3.50 143. ## 8 69306 69306_04 50 2014-01-08 18:08:32 2014-01-08 19:30:40 1.37 56.1 ## 9 69306 69306_05 155 2014-01-09 14:47:04 2014-01-09 19:21:32 4.57 161. ## 10 69307 69307_01 133 2014-01-06 14:04:22 2014-01-06 17:53:01 3.81 144. ## # … with 3 more variables: max_dist &lt;dbl&gt;, direction &lt;dbl&gt;, complete &lt;chr&gt;, and ## # abbreviated variable names ¹​duration, ²​total_dist ## view unique individual ID unique(sumTrips$ID) ## [1] &quot;69302&quot; &quot;69305&quot; &quot;69306&quot; &quot;69307&quot; &quot;69308&quot; &quot;69309&quot; &quot;69310&quot; &quot;69311&quot; &quot;69312&quot; ## [10] &quot;69313&quot; &quot;69314&quot; &quot;69315&quot; &quot;69316&quot; &quot;69317&quot; &quot;69319&quot; &quot;69320&quot; &quot;69321&quot; &quot;69322&quot; ## [19] &quot;69323&quot; &quot;69324&quot; &quot;69325&quot; &quot;69326&quot; &quot;69327&quot; &quot;69328&quot; &quot;69329&quot; &quot;69330&quot; &quot;69331&quot; ## [28] &quot;69332&quot; &quot;69333&quot; &quot;69334&quot; &quot;69335&quot; &quot;69336&quot; &quot;69337&quot; &quot;69338&quot; &quot;69339&quot; &quot;69340&quot; ## [37] &quot;69341&quot; &quot;69342&quot; &quot;69343&quot; &quot;69344&quot; ## number of individuals with tracking data length(unique(sumTrips$ID)) ## [1] 40 ## number of unique trips from all individuals length(unique(sumTrips$tripID)) ## [1] 213 8.6 projectTracks() track2KBA uses Kernel Density Estimation (KDE) to produce space use estimates for each individual track. In order for these to be accurate, we need to transform the tracking data to an equal-area projection. ## review your input data head(data.frame(trips),2) ## ID date_gmt time_gmt Longitude Latitude lon_colony lat_colony ## 706 69302 2012-07-22 07:52:11 -5.69104 -16.00650 -5.73 -16.01 ## 707 69302 2012-07-22 07:53:50 -5.68132 -16.00096 -5.73 -16.01 ## DateTime tripID X Y Returns StartsOut ColDist ## 706 2012-07-22 07:52:11 69302_01 -5.69104 -16.00650 Yes 3783.071 ## 707 2012-07-22 07:53:50 69302_01 -5.68132 -16.00096 Yes 4870.651 ## dataGroup.Longitude dataGroup.Latitude optional ## 706 -5.69104 -16.00650 TRUE ## 707 -5.68132 -16.00096 TRUE ## run the function tracks &lt;- projectTracks(dataGroup = trips, projType = &#39;azim&#39;, custom=TRUE ) class(tracks) ## [1] &quot;SpatialPointsDataFrame&quot; ## attr(,&quot;package&quot;) ## [1] &quot;sp&quot; str(tracks) ## Formal class &#39;SpatialPointsDataFrame&#39; [package &quot;sp&quot;] with 5 slots ## ..@ data :&#39;data.frame&#39;: 26717 obs. of 14 variables: ## .. ..$ ID : chr [1:26717] &quot;69302&quot; &quot;69302&quot; &quot;69302&quot; &quot;69302&quot; ... ## .. ..$ date_gmt : chr [1:26717] &quot;2012-07-22&quot; &quot;2012-07-22&quot; &quot;2012-07-22&quot; &quot;2012-07-22&quot; ... ## .. ..$ time_gmt : chr [1:26717] &quot;07:52:11&quot; &quot;07:53:50&quot; &quot;07:55:29&quot; &quot;07:57:08&quot; ... ## .. ..$ Longitude : num [1:26717] -5.69 -5.68 -5.67 -5.66 -5.65 ... ## .. ..$ Latitude : num [1:26717] -16 -16 -16 -16 -16 ... ## .. ..$ lon_colony: num [1:26717] -5.73 -5.73 -5.73 -5.73 -5.73 -5.73 -5.73 -5.73 -5.73 -5.73 ... ## .. ..$ lat_colony: num [1:26717] -16 -16 -16 -16 -16 ... ## .. ..$ DateTime : POSIXct[1:26717], format: &quot;2012-07-22 07:52:11&quot; &quot;2012-07-22 07:53:50&quot; ... ## .. ..$ tripID : chr [1:26717] &quot;69302_01&quot; &quot;69302_01&quot; &quot;69302_01&quot; &quot;69302_01&quot; ... ## .. ..$ X : num [1:26717] -5.69 -5.68 -5.67 -5.66 -5.65 ... ## .. ..$ Y : num [1:26717] -16 -16 -16 -16 -16 ... ## .. ..$ Returns : chr [1:26717] &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; ... ## .. ..$ StartsOut : chr [1:26717] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## .. ..$ ColDist : num [1:26717] 3783 4871 6407 7759 9007 ... ## ..@ coords.nrs : num(0) ## ..@ coords : num [1:26717, 1:2] -89305 -88267 -86835 -85672 -84723 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : NULL ## .. .. ..$ : chr [1:2] &quot;dataGroup.Longitude&quot; &quot;dataGroup.Latitude&quot; ## ..@ bbox : num [1:2, 1:2] -165053 -113911 -2549 39853 ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:2] &quot;dataGroup.Longitude&quot; &quot;dataGroup.Latitude&quot; ## .. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot; ## ..@ proj4string:Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot ## .. .. ..@ projargs: chr &quot;+proj=laea +lat_0=-15.5025687761751 +lon_0=-4.85666111798403 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs&quot; ## .. .. ..$ comment: chr &quot;PROJCRS[\\&quot;unknown\\&quot;,\\n BASEGEOGCRS[\\&quot;unknown\\&quot;,\\n DATUM[\\&quot;World Geodetic System 1984\\&quot;,\\n &quot;| __truncated__ ## compare input vs. output head(data.frame(trips),2) ## ID date_gmt time_gmt Longitude Latitude lon_colony lat_colony ## 706 69302 2012-07-22 07:52:11 -5.69104 -16.00650 -5.73 -16.01 ## 707 69302 2012-07-22 07:53:50 -5.68132 -16.00096 -5.73 -16.01 ## DateTime tripID X Y Returns StartsOut ColDist ## 706 2012-07-22 07:52:11 69302_01 -5.69104 -16.00650 Yes 3783.071 ## 707 2012-07-22 07:53:50 69302_01 -5.68132 -16.00096 Yes 4870.651 ## dataGroup.Longitude dataGroup.Latitude optional ## 706 -5.69104 -16.00650 TRUE ## 707 -5.68132 -16.00096 TRUE head(data.frame(tracks),2) ## ID date_gmt time_gmt Longitude Latitude lon_colony lat_colony ## 706 69302 2012-07-22 07:52:11 -5.69104 -16.00650 -5.73 -16.01 ## 707 69302 2012-07-22 07:53:50 -5.68132 -16.00096 -5.73 -16.01 ## DateTime tripID X Y Returns StartsOut ColDist ## 706 2012-07-22 07:52:11 69302_01 -5.69104 -16.00650 Yes 3783.071 ## 707 2012-07-22 07:53:50 69302_01 -5.68132 -16.00096 Yes 4870.651 ## dataGroup.Longitude dataGroup.Latitude optional ## 706 -89304.69 -55936.88 TRUE ## 707 -88266.78 -55319.80 TRUE ## compare projections proj4string(trips) ## [1] &quot;+proj=longlat +datum=WGS84 +no_defs&quot; proj4string(tracks) ## [1] &quot;+proj=laea +lat_0=-15.5025687761751 +lon_0=-4.85666111798403 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs&quot; NOTE: Above you have changed your main object name from trips to tracks ##findScale() findScale() provides options for setting the all-important smoothing parameter in the KDE. findScale() calculates candidate smoothing parameter values using different methods. Choosing the ‘optimal’ smoothing parameter is critical. See GitHub page. Consider what further advice we can give to users regarding choice of smoothing parameter? hVals &lt;- findScale( tracks = tracks, scaleARS = TRUE, sumTrips = sumTrips) ## Review output hVals ## med_max_dist step_length mag href scaleARS ## 1 22.97 0.92 3.13 5.78 29.5 ## must choose between one of three smoothing parameters for further analyses ## smoothing parameter is distance in km. Read more in supporting documents. ## Review each outputted smoothing parameter option hVals$mag # affected by range of animal movement. Only works for central place foragers. ## [1] 3.13 hVals$href # sort of represents quality of data ## [1] 5.78 hVals$scaleARS # affected by quality of data and subsequent ability to determine scale at which animal interacts with environment. Learn more about First Passage Time analysis ## [1] 29.5 8.7 estSpaceUse() #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## estSpaceUse() ---- ## Produce KDEs for each individual ## Note: here we might want to remove the trip start and end points that fall ## within the innerBuff distance we set in tripSplit, so that they don&#39;t skew ## the at-sea distribution towards to colony. #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## review input again head(data.frame(tracks),2) ## ID date_gmt time_gmt Longitude Latitude lon_colony lat_colony ## 706 69302 2012-07-22 07:52:11 -5.69104 -16.00650 -5.73 -16.01 ## 707 69302 2012-07-22 07:53:50 -5.68132 -16.00096 -5.73 -16.01 ## DateTime tripID X Y Returns StartsOut ColDist ## 706 2012-07-22 07:52:11 69302_01 -5.69104 -16.00650 Yes 3783.071 ## 707 2012-07-22 07:53:50 69302_01 -5.68132 -16.00096 Yes 4870.651 ## dataGroup.Longitude dataGroup.Latitude optional ## 706 -89304.69 -55936.88 TRUE ## 707 -88266.78 -55319.80 TRUE #min(tracks$ColDist) warning(&quot;Must update GitHub tutorial which specifies distance incorrectly&quot;) ## remove trip start and end points near colony - distance is in m (unlike innerBuff where distance was in km) proj4string(tracks) ## [1] &quot;+proj=laea +lat_0=-15.5025687761751 +lon_0=-4.85666111798403 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs&quot; tracks &lt;- tracks[tracks$ColDist &gt; 3*1000, ] ## produce the KDEs for each individual ## NOTE: The grid cell size (i.e., grid resolution) should be less than the ## selected h value, otherwise the entire space use area of the animal may be ## encompassed in few cells KDE &lt;- estSpaceUse( tracks = tracks, scale = hVals$mag, levelUD = 50, polyOut = TRUE ) ## use the simple mapping function to get an overview of UDs for individuals mapKDE(KDE = KDE$UDPolygons, colony = colony) 8.8 Review smoothing After applying estSpaceUse and viewing plot with mapKDE, at this step we should verify that the smoothing parameter value we selected is producing reasonable space use estimates, given what we know about our study animals. Are the core areas much larger than expected? Much smaller? If so, consider using a different value for the scale parameter. ## convert to sf object trips_sf_IndBird &lt;- st_as_sf(trips) %&gt;% dplyr::filter(ID == unique(trips$ID)[1]) ## get the UD for a single individual ud_sf_IndBird &lt;- KDE$UDPolygons %&gt;% dplyr::filter(id == trips_sf_IndBird$ID[1]) %&gt;% st_transform(.,crs = st_crs(trips_sf_IndBird)) ## Plot OVERALL data again for first single individual plot(st_geometry(trips_sf_IndBird), cex = 0.5, pch = 1) ## and add the UD to the plot plot(st_geometry(ud_sf_IndBird),add=T, border = &quot;blue&quot;) ## Determine number of points captured in UD ## sf::sf_use_s2(FALSE) # run this if issues with st_intersection: https://stackoverflow.com/questions/68478179/how-to-resolve-spherical-geometry-failures-when-joining-spatial-data ## PointsInUD &lt;- st_intersection(trips_sf_IndBird, ud_sf_IndBird) ## nrow(trips_sf_IndBird) ## length(unique(PointsInUD$DateTime)) ## length(unique(PointsInUD$DateTime)) / nrow(trips_sf_IndBird) * 100 warning(&quot;Assess whether your selected smoothing parameter has resulted in sensible Utilisation Distributions.&quot;) warning(&quot;Can we use the above to consider some form of test to guide smoothing parameter choice?.&quot;) 8.9 repAssess() Estimate how representative this sample of animals is of the population. NOTE: iterations should be set to 100 at a minimum when running the script officially. #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## repAssess() ---- ## estimate how representative this sample of animals is of the population. #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &quot;NOTE: See iterations&quot; ## [1] &quot;NOTE: See iterations&quot; repr &lt;- repAssess( tracks = tracks, KDE = KDE$KDE.Surface, levelUD = 50, iteration = 1, ## iterations should be set to 100 at a minimum when running the script officially bootTable = FALSE) 8.10 findSite() #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ## findSite() ---- ## using findSite we can identify areas where animals are overlapping in space ## and delineate sites that meet some criteria of importance. #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ # ## indicate the population size of your source populaiton. e.g. the population size # ## of the colony from which you tracked birds. For KBA identification, this estimate # ## should be in Mature Individuals. # ## I.e. for seabird colonies: breeding pairs * 2 = mature individuals # SourcePopulationSize = 500 # # ## findSite function # Site_PolyTrue &lt;- findSite( # KDE = KDE$KDE.Surface, # represent = repr$out, # levelUD = 50, # popSize = SourcePopulationSize, # 500 individual seabirds breed one the island # polyOut = TRUE # ) # # ## review outputs # dim(Site_PolyTrue) # # ## plot option # Sitemap_PolyTrue &lt;- mapSite(Site_PolyTrue, colony = colony) # # ## review output object # Sitemap_PolyTrue # # ## If in findSite we instead specify polyOut=FALSE, our output will be a spatial # ## grid of animal densities, with each cell representing the estimated number, or # ## percentage of animals using that area. So this output is independent of the # ## representativness-based importance threshold. i.e. the output indicates # ## only the areas used by more or less individuals that you tracked, it does not # ## give you a polygon that you would necessarily assess against IBA / KBA criteria. # ## The output also does not use the representatives measure to estimate the OVERALL # ## number of individuals that are likely using certain areas when you specify the # ## popSize of your source population. # # ## findSite with polyOut=FALSE # Site_PolyFalse &lt;- findSite( # KDE = KDE$KDE.Surface, # represent = repr$out, # levelUD = 50, # popSize = SourcePopulationSize, # 500 individual seabirds breed one the island # polyOut = FALSE # ) # # ## review outputs # dim(Site_PolyFalse) # max(Site_PolyFalse@data$N_IND) # max(Site_PolyFalse@data$N_animals) # head(unique(Site_PolyFalse@data$ID_IND)) # # ## simple plot option # Sitemap_PolyFalse &lt;- mapSite(Site_PolyFalse, colony = colony) # # ## review output object # Sitemap_PolyFalse "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
