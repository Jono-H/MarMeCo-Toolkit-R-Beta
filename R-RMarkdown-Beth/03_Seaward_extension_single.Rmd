---
author: "Bethany Clark"
date: '2023-05-05'
output: html_document
---

<!--- This is an HTML comment in RMarkdown. You can use these comments to make notes that won't get read when running the code -->

<!--- {-} curly brackets hash means subsections won't get numbered -->

## Seaward Extensions: Single colony

This analysis was performed in **`r sessionInfo()$R.version$version.string`**\

This document was last updated on **`r Sys.Date()`** 
<br><br>

**What does this section cover:**

-   Create a seaward extension raster and polygon for a colony of breeding seabirds

**Input data:**

-   Seabird breeding colony location (latitude and longitude)
-   Abundance estimate for seabird breeding colony 
-   Global abundance estimate for seabird species
-   Estimate of appropriate distance travelled from the colony for behaviour of interest (foraging, or behaviours near to the colony such as rafting, bathing, preening, collecting nesting material). This is usually estimate from tracking data for the species collected at different site. [add guidance on how to find this information]
-   Background raster showing terrestrial and marine cells created in the previous section
-   Polygon of land

<!--- Add a space after the line to start the bulleted list -->

<!--- Placing **text** will make text bold -->

<!--- In the code chunk below, we specify include = F, so that we will run the chunk but not include the chunk in the final document. We set a global argument in the code chunk of echo = T, so that in later code chunks, the code will be displayed in the RMarkdown document -->

```{r swe2-setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
## we also specify in the options here to set the overall working directory
## back to the root directory of the R Project we are working in. We do this
## because by default , the working directory for R code chunks is the directory 
## that contains the Rmd document. We don't want this option given our file
## set up prefers the option of having the working directory specified as that
## where the R Project is.
knitr::opts_knit$set(root.dir = "..")

wd <- getwd()
```

**Load required R packages:**

If the packages fail to load, you will need to install them.
If the install script fails, try downloading a new version of R here: https://cran.rstudio.com/index.html 
If that fails try installing Rtools.

```{r swe2-load-packages, include = TRUE}
## Load libraries ####

#install.packages("sf")
#install.packages("terra")
#install.packages("tidyverse")
#install.packages("circular")
#install.packages("geosphere")
library(sf)
library(terra)
library(tidyverse)
#library(circular) #for circular stastics
#library(geosphere) #might need updating if reliant on rgdal


```

**Supply input data**

```{r swe2-input}
## Colony location
latitude <- -60.683
longitude <- -45.644

#Colony size
colony_size <- 3046
#[add guidance, bp?]

#Global population size (this is not the real value, just used for the example!)
global_pop_size <- 200000

#where can partner's get the global estimate
# - we can get data through birdlife if not availabel on the red list
#make sure it is mature individuals - not breeding pairs!
#first place to look is red list


## Maximum colony radius distance (m)
max_colony_radius <- 149000

#add in red list 
#if they are globally threatened, only need 20 mature indivudals

## Raster
ras <- terra::rast(paste0(wd,"/data-input-files-bookdown/seaward-ext-background-raster-single.tif"))

## Land polygon
basemap <- sf::read_sf(paste0(wd,"/data-input-files-bookdown/Coastline_high_res_polygon_v7.1"))


```

**Format colony location as spatial objects**

If the colony location is not projected into an equal areas crs with metres (m) as the unit, this will need to be done before calculating the distance. 
[add guidance on choosing projections]

```{r swe2-crs}
#format colony location as dataframe
df <- data.frame(cbind(latitude,longitude,colony_size))

#Set coordinate reference system (CRS) for colony locations (example for lat/lon, WGS84)
col_locs <- sf::st_as_sf(df,coords = c("longitude","latitude"),
         crs = 4326) 

#If needed, convert colony data to basemap projection
if(sf::st_crs(col_locs) != sf::st_crs(ras)){
  col_locs_proj <- sf::st_transform(col_locs, crs = st_crs(ras))
} else {
  col_locs_proj <- col_locs
}


```


**Calculate distance by sea from the colony per cell**

-   Calculate distances from the colony to each cell travelling only through marine cells, because the birds are expect to travel around land masses rather than over them to reach marine destinations.


```{r swe2-calcdist}

## Extract the cell location of the colony
pp <- terra::extract(ras,vect(col_locs_proj), cells=TRUE) 

## convert that cell to a value of 3 
ras[pp$cell] <- 3
ras[ras==2] <- NA

## You now have a raster with colony cell = 3, land cells = 2 and sea cells =1

## Calculate distance from colony via sea, cell values of NA are avoided while determining distance
DistSea <- terra::gridDist(x=ras,    # x specifies which raster to use
                           target=3) # specifies which cell to determine distance from

if(terra::minmax(DistSea)[2] == 0) print("WARNING: Check for NAs in final output. Your origin(colony) may be to far in land. 
                                                  Therefore, your origin is completely buffered by omit cells (land cells), 
                                                  and no distance calculation for cells at sea can be performed") else print(
                                         "Distance calculation successful")

plot(DistSea) 

```


**Calculate estimate number of birds from the colony using each cell**

1. Set any cells that are further that the provided maximum distance from the colony
2. Normalise to 0 and 1 probability of occurrence instead of distance
3. Multiple by colony size

```{r swe2-dist_to_pop}

## Set any cell further than maximum distance to NA
DistSea[DistSea > max_colony_radius] <- NA

## Normalise to 0 and 1 probability of occurrence (linear decay)
DistSea <- -1*(DistSea/max_colony_radius)+1 

## Could can change to exponential or other decay function instead.
## [add options]

#Multiply by population size
PopRaster <- DistSea*colony_size

plot(PopRaster) 

```


**Save raster outputs**

-   Crop the raster to reduce file size and then save


```{r swe2-save}

#create folders for maps to check results
outputs <- "/seaward_extension_outputs"
dir.create(outputs)

##Make buffer to crop raster
max_dist_buffer <- st_buffer(col_locs_proj, dist = max_colony_radius)

#crop to reduce size for saving
PopRaster <- terra::crop(PopRaster,
                       max_dist_buffer,
                       snap = "out")
#save
terra::writeRaster(PopRaster,paste0(wd,outputs,"/seaward-ext-single-col-dist.tif"), overwrite=T)

```



**Calculate IBA raster**

-   Filter out cells containing less than 1% of the global population


```{r swe2-iba-ras}

#Convert to with more (1) or less (0) than 1% of global population 
IBA_raster <- PopRaster
IBA_raster[IBA_raster < global_pop_size/100] <- 0
IBA_raster[IBA_raster >= global_pop_size/100] <- 1


#plot to check
plot(IBA_raster) 

#set to NA cells 
IBA_raster[IBA_raster == 0] <- NA

#need to save min and max value for IBA forms

```


**Calculate IBA polygon**

-   Convert to polygon format
-   Simplify the polygon to a more usable shape
-   Cut out the area covered by land
-   Save the output

[consider what to do with small holes by the coast]


```{r swe2-poly}

#convert raster to a polygon format
IBA_poly_ras <- IBA_raster %>%
  terra::as.polygons() %>%
  sf::st_as_sf()

#simplify the polygon
IBA_poly <- IBA_poly_ras %>%
  sf::st_buffer(dist = res(IBA_raster)[1]/4) %>%
  sf::st_simplify(dTolerance = res(IBA_raster)[1]) 
  
#get local part of basemap  
land <- basemap %>% 
  st_crop(st_bbox(max_dist_buffer)) %>%
  st_union()

#plot the result
ggplot(IBA_poly)+
   geom_sf(data = IBA_poly_ras, fill = "blue")+
   geom_sf(data = land)+
   geom_sf(fill = NA, color = "orange") 

#set up fill holes function

st_fill_holes <- function (x, max_area = 0) {
    geom = st_geometry(x)
        dat = st_set_geometry(x, NULL)
    for (i in 1:length(geom)) {
        if (st_is(geom[i], "MULTIPOLYGON")) {
            tmp = st_cast(geom[i], "POLYGON")
            for (j in 1:length(tmp)) {
                if (length(tmp[j][[1]]) > 1) {
                  if (max_area > 0) {
                    holes = lapply(tmp[j][[1]], function(x) {
                      st_polygon(list(x))
                    })[-1]
                    holes = lapply(holes, function(h) st_sfc(h, 
                      crs = st_crs(x)))
                    areas = c(Inf, sapply(holes, st_area))
                    tmp[j] = st_polygon(tmp[j][[1]][which(areas > 
                      max_area)])
                  }
                  else {
                    tmp[j] = st_polygon(tmp[j][[1]][1])
                  }
                }
            }
            geom[i] = st_combine(tmp)
        }
    }
        geom = st_sf(dat, geometry = geom)
}


#trim out the areas covered by land
IBA_poly_trim <- st_union(IBA_poly, land) %>%
  st_fill_holes() %>%  
  st_difference(land)

#plot the final polygon
ggplot(IBA_poly_trim)+
    geom_sf(data = land) +
    geom_sf(fill = "orange")

#plot the final polygon with foraging radius approach
ggplot(max_dist_buffer)+
    geom_sf(fill = NA, col = "blue")+
    geom_sf(data = IBA_poly_trim, fill = "#fcba0350", col = "orange")+
    geom_sf(data = land, fill = "darkgrey") 


#add metadata to the polygon before saving
#add metadata to the plot

#save the polygon
#st_write(IBA_poly_trim,layer = "IBA_polygon")





```





